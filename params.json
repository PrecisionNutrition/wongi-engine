{"name":"Wongi-engine","tagline":"A rule engine written in Ruby.","body":"# Wongi::Engine\r\n\r\nThis library contains a rule engine written in Ruby. It's based on the [Rete algorithm](http://en.wikipedia.org/wiki/Rete_algorithm) and uses a DSL to express rules in a readable way.\r\n\r\n[![Build Status](https://travis-ci.org/ulfurinn/wongi-engine.svg?branch=master)](https://travis-ci.org/ulfurinn/wongi-engine) (MRI 1.9.3, 2.0, 2.1, 2.2, Rubinius, JRuby)\r\n\r\n## Word of caution\r\n\r\nThis is complex and fragile machinery, and there may be subtle bugs that are only revealed with nontrivial usage. Be conservative with upgrades, test your rules extensively, and please report any behaviour that is not consistent with your expectations.\r\n\r\n## Tutorial\r\n\r\nTo begin, say\r\n\r\n\tengine = Wongi::Engine.create\r\n\r\nNow let's add some facts to the system.\r\n\r\n### Facts\r\n\r\nAll knowledge in Wongi::Engine is represented by triples of { subject, predicate, object }. Predicates usually stand for subjects' properties, and objects for values of those properties. More complex types can always be decomposed into such triples.\r\n\r\nTriples can contain any Ruby object that defines the `==` comparison in a meaningful way, but some symbols have special meaning, as we will see.\r\n\r\nTry this:\r\n\r\n```ruby\r\nengine << [ \"Alice\", \"friend\", \"Bob\" ]\r\nengine << [ \"Alice\", \"age\", 35 ]\r\n```\r\n\r\nTo remove facts, say:\r\n\r\n```ruby\r\nengine.retract [ \"Alice\", \"age\", 35 ]\r\n```\r\n\r\nWhat can we do with this information?\r\n\r\n### Simple iteration\r\n\r\nSuppose we want to list all we know about Alice. You could, for instance, do:\r\n\r\n```ruby\r\nengine.each \"Alice\", :_, :_ do |item|\r\n\tputs \"Alice's #{item.predicate} is #{item.object}\"\r\nend\r\n```\r\n\r\n`each` takes three arguments for every field of a triple and tries to match the resulting template against the known facts. `:_` is the special value that matches anything. This kind of pattern matching plays a large role in Wongi::Engine; more on that later.\r\n\r\nIn a similar way, you can use `select` to get an array of matching facts and `find` to get the first matching one. Both methods take three arguments.\r\n\r\n### Simple rules\r\n\r\nIt's not very interesting to use the engine like that, though. Rule engines are supposed to be declarative. Let's try this:\r\n\r\n```ruby\r\nfriends = engine.rule \"friends\" do\r\n\tforall {\r\n\t\thas :PersonA, \"friend\", :PersonB\r\n\t}\r\nend\r\n```\r\n\r\nHere's your first taste of the engine's DSL. A rule, generally speaking, consists of a number of conditions the dataset needs to meet; those are defined in the `forall` section (also spelled `for_all`, if you prefer that). `has` (or `fact`) specifies that there needs to be a fact that matches the given pattern; in this case, one with the predicate `\"friend\"`.\r\n\r\nWhen a pattern contains a symbol that starts with an uppercase letter, it introduces a variable which will be bound to an actual triple field. Their values can be retrieved from the result set:\r\n\r\n```ruby\r\nfriends.tokens.each do |token|\r\n\tputs \"%s and %s are friends\" % [ token[ :PersonA ], token[ :PersonB ] ]\r\nend\r\n```\r\n\r\nA **token** represents all facts that passed the rule's conditions. If you think of the dataset as of a long SQL table being joined with itself, then a token is like a row in the resulting table.\r\n\r\nIf you don't care about a specific field's value, you can use the all-matcher `:_` in its place so as not to introduce unnecessary variables.\r\n\r\nOnce a variable is bound, it can be used to match further facts within a rule. Let's add another friendship:\r\n\r\n```ruby\r\nengine << [ \"Bob\", \"friend\", \"Claire\" ]\r\n```\r\n\r\nand another rule:\r\n\t\r\n```ruby\r\nremote = engine.rule \"remote friends\" do\r\n\tforall {\r\n\t\thas :PersonA, \"friend\", :PersonB\r\n\t\thas :PersonB, \"friend\", :PersonC\r\n\t}\r\nend\r\n\r\nremote.tokens.each do |token|\r\n\tputs \"%s and %s are friends through %s\" % [ token[ :PersonA ], token[ :PersonC ], token[ :PersonB ] ]\r\nend\r\n```\r\n\r\n(`engine.rule` returns the created **production node** - an object that accumulates the rule's result set. You don't have to carry it around if you don't want to - it is always possible to retrieve it later as `engine.productions[\"remote friends\"]`.)\r\n\r\n### Stored queries\r\n\r\nTaking the SQL metaphor further, you can use the engine to do fancy searches:\r\n\r\n```ruby\r\nq = engine.query \"friends\" do\r\n\tsearch_on :Name\r\n\tforall {\r\n\t\thas :Name, \"friend\", :Friend\r\n\t}\r\nend\r\n\r\nengine.execute \"friends\", { Name: \"Alice\" }\r\nq.tokens.each do |token|\r\n\t... # you know the drill\r\nend\r\n```\r\n\r\nNot that this is a particularly fancy search, but you get the idea.\r\n\r\nQueries work the same way as normal rules, but they come with some variables already bound by the time matching starts.\r\n\r\nYou can also retrieve the query's production node from `engine.results[\"friends\"]` (they are intentionally kept separate from regular productions).\r\n\r\n### Taking an action\r\n\r\nThere's more to rules than passive accumulation:\r\n\r\n```ruby\r\nengine.rule \"self-printer\" do\r\n\tforall {\r\n\t\thas :PersonA, \"friend\", :PersonB\r\n\t}\r\n\tmake {\r\n\t\taction { |token|\r\n\t\t\tputs \"%s and %s are friends\" % [ token[ :PersonA ], token[ :PersonB ] ]\r\n\t\t}\r\n\t}\r\nend\r\n```\r\n\r\nThe `make` section (also spelled `do!`, if you find it more agreeable English, because `do` is a keyword in Ruby) lists everything that happens when a rule's conditions are fully matched (we say \"the production node is **activated**\"). Wongi::Engine provides only a small amount of built-in actions, but you can define your own ones, and the simplest one is just `action` with a block. The block will be executed in the engine's context.\r\n\r\n### More facts!\r\n\r\nNote how our facts define relations that always go from subject to object - they form a directed graph. In a perfect world, friendships go both ways, but to specify this in our model, we need to have two facts for each couple. Instead of duplicating everything by hand, let's automate that:\r\n\r\n```ruby\r\nengine.rule \"symmetric predicate\" do\r\n\tforall {\r\n\t\thas :Predicate, \"symmetric\", true\r\n\t\thas :X, :Predicate, :Y\r\n\t}\r\n\tmake {\r\n\t\tgen :Y, :Predicate, :X\r\n\t}\r\nend\r\n\r\nengine << [\"friend\", \"symmetric\", true]\r\n```\r\n\r\nIf you still have the \"self-printer\" rule installed, you will see some new friendships pop up immediately!\r\n\r\nThe built-in `gen` action creates new facts, taking either fixed values or variables as arguments. (It will complain if you provide a variable that isn't bound by the time it's activated.) Here, it takes all relations we've defined to be [symmetric](http://en.wikipedia.org/wiki/Symmetric_relation), finds all couples in those sorts of relations and turns them around.\r\n\r\n### Matchers\r\n\r\nIt wouldn't be very useful if `has` were the only sort of condition that could be used. Here are some more:\r\n\r\n#### `neg subject, predicate, object`\r\n\r\nPasses if the specified template does *not* match anything in the dataset. Alias: `missing`.\r\n\r\n#### `maybe subject, predicate, object`\r\n\r\nPasses whether or not the template matches anything. It's only useful if it introduces a new variable; you can think of `LEFT JOIN`. Alias: `optional`.\r\n\r\n#### `none { ... }`\r\n\r\nThe `none` block contains other matchers and passes if that *entire subchain* returns an empty set. In other words, it corresponds to an expression `not ( a and b and ... )`.\r\n\r\n#### `any { option { ... } ... }`\r\n\r\nThe `any` block contains several `option` blocks, each of them containing other matchers. It passes if any of the `option` subchains matches. It's a shame that disjunction has to be so much more verbose than conjunction, but life is cruel.\r\n\r\n#### `same x, y`\r\n\r\nPasses if the arguments are equal. Alias: `eq`, `equal`.\r\n\r\n#### `diff x, y`\r\n\r\nPasses if the arguments are not equal. Alias: `ne`.\r\n\r\n#### `less x, y`, `greater x, y`\r\n\r\nShould be obvious by now.\r\n\r\n#### `assuming rule_name`\r\n\r\nThis is a shortcut for extending a common base rule with additional matchers. `rule_name` must already be installed on the same engine instance. `assuming` must be the first clause in the extending rule.\r\n\r\n```ruby\r\nengine << rule( :base ) {\r\n  forall {\r\n    has :x, :y, :Z\r\n  }\r\n}\r\n\r\nengine << rule {\r\n  forall {\r\n    assuming :base\r\n    has :Z, :u, :W\r\n  }\r\n}\r\n```\r\n\r\n#### `assert { |token| ... }`, `assert var1, var2, ... do |val1, val2, ... | ... end`\r\n\r\nPasses if the block evaluates to `true`. Having no arguments passes the entire token as an argument, listing some variables passes only their values.\r\n\r\n#### `assign variable do |token| ... end`\r\n\r\nNot a *matcher*, strictly speaking, because it always passes. What it does instead is introduce a new variable bound to the block's return value.\r\n\r\n### Feedback loop prevention\r\n\r\nConsider the following rule:\r\n\r\n```ruby\r\nengine.rule \"default value\" do\r\n\tforall {\r\n\t\tneg :car, :colour, :_\r\n\t}\r\n\tmake {\r\n\t\tgen :car, :colour, \"black\"\r\n\t}\r\nend\r\n```\r\n\r\nThe intent here is to provide a default value for an attribute; however, how will it actually execute?\r\n\r\n1. The fact is missing, activate the rule, generate the fact.\r\n2. The fact is present, invalidate the rule, retract the generated fact.\r\n3. The fact is missing...\r\n\r\n...and so on until you get a stack overflow. In situations like this the engine will try to do the pragmatic thing and detect the loop, stopping after step 1. If you want to keep the \"pure\" behaviour, give the `unsafe: true` option to the `neg` rule and try to do the same thing with helper facts.\r\n\r\n**Note**: this is a specific use case; it is still perfectly possible to construct more elaborate infinite cascades involving several rules that will not be caught.\r\n\r\n### Timeline\r\n\r\nWongi::Engine has a limited concept of timed facts: time is discrete and only extends into the past. Matchers that accept a triple specification (`has`, `neg` and `maybe`) can also accept a `time` option, an integer <= 0, which will make them look at a past state of the system. \"0\" means the current state and is the default value, \"-1\" means the one just before the current, and so on.\r\n\r\nTo create past states, say:\r\n\r\n```ruby\r\nengine.snapshot!\r\n```\r\n\r\nThis will shift all facts one step into the past. The new current state will be a copy of the last one. You can only insert new facts into the current state, \"retroactive\" facts are not allowed.\r\n\r\n### Time-aware matchers\r\n\r\nThe following matchers are nothing but syntactic sugar for a combination of primitives.\r\n\r\n#### `asserted subject, predicate, object`\r\n\r\nShort for:\r\n\t\r\n```ruby\r\nhas subject, predicate, object, time: 0\r\nneg subject, predicate, object, time: -1\r\n```\r\n\r\nThat is, it passes if the fact was missing in the previous state but exists in the current one. Alias: `added`.\r\n\r\n#### `retracted subject, predicate, object`\r\n\r\nShort for:\r\n\r\n```ruby\r\nhas subject, predicate, object, time: -1\r\nneg subject, predicate, object, time: 0\r\n```\r\n\r\nThe reverse of `asserted`. Alias: `removed`.\r\n\r\n#### `kept subject, predicate, object`\r\n\r\nShort for:\r\n\r\n```ruby\r\nhas subject, predicate, object, time: -1\r\nhas subject, predicate, object, time: 0\r\n```\r\n\r\nAlias: `still_has`.\r\n\r\n#### `kept_missing subject, predicate, object`\r\n\r\nShort for:\r\n\r\n```ruby\r\nneg subject, predicate, object, time: -1\r\nneg subject, predicate, object, time: 0\r\n```\r\n\r\nSince neg rules cannot introduce new variables, neither can this one.\r\n\r\nAlias: `still_missing`.\r\n\r\n### Other built-in actions\r\n\r\n#### `collect variable, collector_name`\r\n\r\nIf you use this action, `engine.collection( collector_name )` will provide a `uniq`'ed array of all values `variable` has been bound to. It's a bit shorter than iterating over the tokens by hand.\r\n\r\n#### `error message`, `error { |hash_of_variable_assignments| ... }`\r\n\r\nUseful when you want to detect contradictory facts. `engine.errors` will give an array of all error messages produced when this action is activated. If you use the block form, the block needs to return a message.\r\n\r\n#### `trace options`\r\n\r\nThe debugging action that will print a message every time it's activated. Possible options are:\r\n\r\n* `values` (boolean = false): whether to print variable assignments as well\r\n* `io` (IO = $stdout): which IO object to use\r\n* `generation` (boolean = false): whether this rule's `gen` action should print messages too. `trace` must come before any `gen` actions in this case.\r\n* `tracer`, `tracer_class`: a custom tracer that must respond to `trace` and accept a hash argument. Hash contents will vary depending on the action being traced.\r\n\r\n### Custom actions\r\n\r\nWe've seen one way to specify custom actions: using `action` with a block. Another way to use it is to say:\r\n\r\n```ruby\r\naction class, ... do\r\n\t...\r\nend\r\n```\r\n\r\nAny additional arguments or blocks will be given to `initialize`, and the class must define an `execute` method taking a token. Passing any object with an `execute` method also works.\r\n\r\nIf your action class inherits from `Wongi::Engine::Action`, you'll have the following (more or less useful) attributes:\r\n\r\n* `rete`: the engine instance\r\n* `rule`: the rule object that is using this action\r\n* `name`: the extension clause used to define this action (read more under [DSL extensions](#dsl-extensions))\r\n* `production`: the production node\r\n\r\nIf you can't or don't want to inherit, you can define the accessors yourself. Having just the ones you need is fine.\r\n\r\n### Organising rules\r\n\r\nUsing `engine.rule` and `engine.query` is fine if you want to experiment, but to make rules and queries more manageable, you will probably want to keep them separate from the engine instance. One way to do that is to just say:\r\n\r\n```ruby\r\nmy_rule = rule \"name\" do\r\n\t...\r\nend\r\n\r\nengine << my_rule\r\n```\r\n\r\nFor even more convenience, why not group rules together:\r\n\r\n```ruby\r\nmy_ruleset = ruleset {\r\n\trule \"rule 1\" do\r\n\t\t...\r\n\tend\r\n\trule \"rule 2\" do\r\n\t\t...\r\n\tend\r\n}\r\n\r\nengine << my_ruleset\r\n```\r\n\r\nAgain, you don't need to hold on to object references if you don't want to:\r\n\r\n```ruby\r\nruleset \"my set\" do\r\n\t...\r\nend\r\n\r\nengine << Wongi::Engine::Ruleset[ \"my set\" ]\r\n```\r\n\r\n### DSL extensions\r\n\r\nThis is a more advanced method of customising. In general, DSL extensions have the form:\r\n\r\n```ruby\r\ndsl {\r\n\tsection [ :forall | :make ]\r\n\tclause :my_action\r\n\t[ action | accept | body ] ...\r\n}\r\n```\r\n\r\nwhich is then used in a rule like this:\r\n\r\n```ruby\r\nmake {\r\n\tmy_action ...\r\n}\r\n```\r\n\r\nDSL extensions are globally visible to all engine instances.\r\n\r\nLet's have a look at the three ways to define a clause's implementation.\r\n\r\n#### `body { |...| ... }`\r\n\r\nThis simply allows you to group several other actions or matchers. It is perhaps the only way you have to extend the `forall` section, as any non-trivial matchers will require special support from the engine itself.\r\n\r\n#### `action class`, `action do |token| ... end`\r\n\r\nThis works almost exactly like using the `action` action directly in a rule, but gives it a more meaningful alias. Arguments to `initialize`, however, are taken from the action's invocation in `make`, not the definition.\r\n\r\nA useful pattern is having specialised named collectors, defined like this:\r\n\r\n```ruby\r\ndsl {\r\n\tsection :make\r\n\tclause :my_collection\r\n\taction Wongi::Engine::SimpleCollector.collector\r\n}\r\n```\r\n\r\ninstalled like this:\r\n\r\n```ruby\r\nrule('collecting') {\r\n\t...\r\n\tmake {\r\n\t\tmy_collection :X\r\n\t}\r\n}\r\n```\r\n\r\nand accessed like this:\r\n\r\n```ruby\r\ncollection = engine.collection :my_collection\r\n```\r\n\r\n#### `accept class`\r\n\r\nMost library users probably won't need this, but it's here for completion. Acceptors represent an intermediate state. They allow you to have some shared data that you customize for a given engine instance. The class needs to respond to `import_into( engine_instance )` and return something usable as an action, or to be usable as an action itself.\r\n\r\nThe class also gets arguments to `initialize` from the action's invocation.\r\n\r\n## Acknowledgements\r\n\r\nThe Rete implementation in this library largely follows the outline presented in [\\[Doorenbos, 1995\\]](http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf).\r\n\r\n## Changelog\r\n\r\n### 0.1.0\r\n\r\n* massively rewritten rule activation; this simplifies development and debugging and opens the road for useful features such as fully reversible custom actions\r\n\r\n### 0.0.17\r\n\r\n* introduced the `assuming` matcher\r\n\r\n### 0.0.13\r\n\r\n* fixed a bug with recursive generations of multiple facts\r\n\r\n### 0.0.12\r\n\r\n* fixed another NCC bug\r\n\r\n### 0.0.11\r\n\r\n* fixed cleanup of invalidated NCC branches\r\n\r\n### 0.0.10\r\n\r\n* fixed interaction of filters and optional nodes\r\n\r\n### 0.0.9\r\n\r\n* fixed the definition of `asserted` (#16)\r\n\r\n### 0.0.8\r\n\r\n* preventing the feedback loop introduced in 0.0.7; experimental\r\n\r\n### 0.0.7\r\n\r\n* added a guard against introducing variables in neg clauses\r\n* fixed execution context of simple action block (#7)\r\n* fixed #4 once more, better\r\n* fixed a bug with OptionalNode (#12)\r\n* fixed behaviour of neg nodes; this will cause feedback loops when a gen action creates a fact that invalidates the action's condition\r\n\r\n### 0.0.6\r\n\r\n* fixed a bug caused by retracting facts from within a rule action (#4)\r\n\r\n### 0.0.5\r\n\r\n* fixed a bug with multiple `assert` tests following the same node (#2)\r\n\r\n### 0.0.4\r\n\r\n* reintegrated RDF support\r\n* collapsible filter matchers\r\n\r\n### 0.0.3\r\n\r\n* bug fixes\r\n* `assert`, `assign`\r\n\r\n### 0.0.1\r\n\r\n* initial repackaged release\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Added some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}